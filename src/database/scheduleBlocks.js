import { db } from "./db";

/**
 * @typedef {Object} ScheduleBlock
 * @property {number} [id] - Unique identifier (auto-generated by Dexie)
 * @property {string} startDate - Start date of the block (YYYY-MM-DD)
 * @property {string} endDate - End date of the block (YYYY-MM-DD)
 * @property {string} [reason] - Optional reason for the block
 */

/**
 * Gets all schedule blocks from the database, sorted by start date.
 * @returns {Promise<ScheduleBlock[]>}
 */
export const getAllScheduleBlocks = async () => {
  try {
    return await db.scheduleBlocks.orderBy("startDate").toArray();
  } catch (error) {
    console.error("Failed to get schedule blocks:", error);
    return [];
  }
};

/**
 * Adds a new schedule block to the database.
 * @param {Omit<ScheduleBlock, 'id'>} block
 * @returns {Promise<number>} The ID of the newly added block.
 */
export const addScheduleBlock = async (block) => {
  try {
    // Basic validation
    if (!block.startDate || !block.endDate) {
      throw new Error(
        "Start date and end date are required for a schedule block."
      );
    }
    if (new Date(block.startDate) > new Date(block.endDate)) {
      throw new Error("Start date cannot be after end date.");
    }
    return await db.scheduleBlocks.add(block);
  } catch (error) {
    console.error("Failed to add schedule block:", error);
    throw error; // Re-throw to indicate failure
  }
};

/**
 * Deletes a schedule block by its ID.
 * @param {number} id
 * @returns {Promise<void>}
 */
export const deleteScheduleBlock = async (id) => {
  try {
    return await db.scheduleBlocks.delete(id);
  } catch (error) {
    console.error("Failed to delete schedule block:", error);
    throw error; // Re-throw to indicate failure
  }
};

/**
 * Checks if a specific date falls within any schedule block.
 * Dates are compared inclusively.
 * @param {string} dateStr - The date to check (YYYY-MM-DD)
 * @param {ScheduleBlock[]} blocks - The list of existing blocks
 * @returns {boolean} True if the date is blocked, false otherwise.
 */
export const isDateBlocked = (dateStr, blocks) => {
  if (!dateStr || !blocks || blocks.length === 0) {
    return false;
  }
  const checkDate = new Date(`${dateStr}T00:00:00Z`); // Use UTC for comparison consistency

  return blocks.some((block) => {
    try {
      const startDate = new Date(`${block.startDate}T00:00:00Z`);
      const endDate = new Date(`${block.endDate}T00:00:00Z`);
      return checkDate >= startDate && checkDate <= endDate;
    } catch (e) {
      console.error("Error parsing block dates:", block, e);
      return false; // Treat invalid blocks as non-blocking
    }
  });
};
